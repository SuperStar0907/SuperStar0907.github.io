<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>AADproject</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic">
    <link rel="stylesheet" href="assets/css/Kalmansk-Regular.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono">
    <link rel="stylesheet" href="assets/fonts/fontawesome-all.min.css">
    <link rel="stylesheet" href="assets/fonts/font-awesome.min.css">
    <link rel="stylesheet" href="assets/fonts/ionicons.min.css">
    <link rel="stylesheet" href="assets/fonts/material-icons.min.css">
    <link rel="stylesheet" href="assets/fonts/simple-line-icons.min.css">
    <link rel="stylesheet" href="assets/fonts/typicons.min.css">
    <link rel="stylesheet" href="assets/fonts/fontawesome5-overrides.min.css">
    <link rel="stylesheet" href="assets/css/Boostrap-Tabs.css">
    <link rel="stylesheet" href="assets/css/CoolFont---Text-Container.css">
    <link rel="stylesheet" href="assets/css/gradient-navbar-1.css">
    <link rel="stylesheet" href="assets/css/gradient-navbar.css">
</head>

<body>
    <nav class="navbar navbar-dark navbar-expand-md" id="app-navbar">
        <div class="container-fluid"><a class="navbar-brand" href="#"><i class="icon-equalizer"></i></a><button data-bs-toggle="collapse" class="navbar-toggler" data-bs-target="#navcol-1"><span class="visually-hidden">Toggle navigation</span><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navcol-1">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item"><a class="nav-link" href="#">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</a></li>
                    <li class="nav-item"><a class="nav-link active" href="#">MST</a></li>
                    <li class="nav-item"></li>
                    <li class="nav-item"></li>
                </ul>
            </div>
        </div>
    </nav>
    <section class="container-padding">
        <div class="container">
            <div class="p-5 mb-4 bg-light round-3">
                <div class="container-fluid py-5">
                    <h1 class="display-5 fw-bold">Minimum Spanning Tree</h1>
                    <p class="col-md-8 fs-4">The minimum spanning tree problem is formulated informally as follows: we are provided an<br>undirected graph G = (V,E) with weights w(e) ∈ R for e ∈ E and we want to compute<br>a subgraph of G that is a tree which connects all vertices in V (a spanning tree) and has minimum total edge weight defined as w(T) = ∑ w(e), e∈T<br>Below is an example of an MST of a graph. In the example, the edges forming the MST are colored blue while edges that are not part of the MST are colored black:<br></p><img src="assets/img/Screen%20Shot%202021-12-01%20at%209.24.47%20AM.png" width="800"/>
                </div>
            </div>
            <div class="p-5 mb-4 bg-light round-3">
                <div class="container-fluid py-5">
                    <h1 class="display-5 fw-bold">Common algorithmic template</h1>
                    <p class="col-md-8 fs-4">A←∅<br>while A is not a spanning tree do<br> find edge (u,v) that is ‘safe’ for A<br> A ← A ∪ {u, v }<br>return A<br><br>--&gt; An edge is considered safe to add to A as long as it maintains the invariant&nbsp;that there exists at least one MST which contains all the edges in A.<br></p>
                </div>
            </div>
            <div class="p-5 mb-4 bg-light round-3">
                <div class="container-fluid py-5">
                    <h1 class="display-5 fw-bold">Cuts and Light Edges</h1>
                    <p class="col-md-8 fs-4">We will introduce the notion of graph cuts to formally discuss which edges can be considered<br>safe to add to the MST edge set. Let a cut (S,V −S) of a graph G = (V,E) be a partition<br>of V into two disjoint sets S and V −S. From this, we can say that an edge (u,v) crosses<br>the cut (S,V −S) if the edge has one endpoint in S and the other in V −S. We can also say<br>that a cut respects a subset A of edges if no edges in A cross the cut. An edge is considered<br>a light edge crossing a cut if its weight is the minimum of any edge crossing the cut.<br> In the example above, let (S, V − S) be a cut of the graph where S contains the set of<br>nodes above the red curve and V − S contains the set of nodes below it, and the set A<br>be the set of edges colored blue. The edges which cross the cut are exactly the following:<br>(a,h),(b,h),(b,c),(c,d),(d,f ),(e,f ) and the only light edge which crosses (S,V − S) is<br>(c,d). Since none of these edges are contained in the set A, the cut respects the set A.<br>Note that if we were to add any of the edges previously mentioned to A, then the cut would no longer respect A.<br><br> Given the definitions above, let G = (V, E) be a connected and undirected graph with edge<br>weights w(e), A be a subset of E such that some MST of G contains A, (S,V −S) be a cut<br>that respects A, and (u, v ) be a light edge crossing (S, V − S).<br></p><img src="assets/img/Screen%20Shot%202021-12-01%20at%2010.06.36%20AM.png" width="800"/>
                </div>
            </div>
            <div class="p-5 mb-4 bg-light round-3">
                <div class="container-fluid py-5">
                    <h1 class="display-5 fw-bold">Some Special Points About MST</h1>
                    <p class="col-md-8 fs-4">Theorem : There exists an MST that contains A ∪ {(u, v )}.<br>The MST algorithm maintains a subset A of edges with no cycles. That is, the graph represented by GA = (V, A) is a forest (a set of distinct unconnected trees).<br>Any safe edge (u,v) connects two distinct connected components of GA. For some connected component C = (VC,EC) in GA, the safe edge (u,v) is a light edge crossing (VC , V − VC ).<br></p>
                </div>
            </div>
            <div class="p-5 mb-4 bg-light round-3">
                <div class="container-fluid py-5">
                    <h1 class="display-5 fw-bold">Prim's Algorithm and Kruskal's Algorithm</h1>
                    <div>
                        <ul class="nav nav-tabs" role="tablist">
                            <li class="nav-item" role="presentation"><a class="nav-link active" role="tab" data-bs-toggle="tab" href="#tab-1">Prim's</a></li>
                            <li class="nav-item" role="presentation"><a class="nav-link" role="tab" data-bs-toggle="tab" href="#tab-2">Kruskal's</a></li>
                        </ul>
                        <div class="tab-content">
                            <div class="tab-pane active" role="tabpanel" id="tab-1"><p>At a high level, the set A maintained by Prim’s algorithm is a single tree. The algorithm starts with an arbitrary root r and in each step, a light edge leading out of A and connecting to a node that has not yet been connected to A is selected and added to A. Once A connects every node in the graph, it is returned as an MST of the graph.<br><br>
Prim’s algorithm is similar to Dijkstra’s algorithm in that estimates of the distance to each node are maintained and updated as the algorithm progresses. Q is a priority queue main- taining distances of vertices not in the tree so far, key(v) is the minimum weight of edge connecting v to some vertex in the tree, and p(v) is the parent of v in the tree.<br><br>
Correctness Much of the correctness of Prim’s algorithm follows from theorem that There exists an MST that contains A ∪ {(u, v )}.. Notice that at the beginning of every loop iteration,<br> A = { (p(v ), v ) : v ∈ (V − {r } − Q)} <br>meaning that the vertices already placed in the partial MST are those in V − Q. For all vertices v ∈ Q <br><br>
<pre>
key(v) ← ∞, ∀v ∈ V
key(r) ← 0
Q ← (key(v), v), ∀v ∈ V p(v) ← NIL, ∀v ∈ V A←∅
while Q is not empty do
    u ← ExtractMin(Q) 
    if u ̸= r then
        A = A ∪ {(p(u), u)}
    for each neighbor v of u do
        if v ∈ Q and w(u,v) < key(v) then
            key(v) = w(u,v)
            DecreaseKey(key(v), v)
            p(v) = u
return A
<br><br>
if p(v) ̸= NIL, then key(v) is the minimum weight of an edge connecting v to the partial MST. 
This can be thought of in terms of graph cuts with partitions (Q, V − Q) and the vertices in Q with non-NIL parents as being the tail of edges crossing this cut. 
Since in Q, only the vertices with non-NIL parents have key ̸= ∞ (except for r in the first iteration), this means that only the edges which cross the cut are considered at each iteration and the one with minimum weight is added to A.
This is exactly what the MST template algorithm does (we add a safe edge) and as such, the correctness of the algorithm follows.
Running time Prim’s Algorithm can be implemented as a direct modification of Dijkstra’s Algorithm and can achieve a similar running time, but its exact bound depends on the imple- mentation of the priority queue.

If a red-black tree or a binary heap is used:
• ExtractMin: O(logn)
• DecreaseKey: O(logn)
• Total: O(nlogn+mlogn)=O(mlogn)

If a Fibonacci heap is used:
• ExtractMin: O(logn)
• DecreaseKey: O(1) amortized • Total: O(nlogn+m)
</pre>
</p></div>
                            <div class="tab-pane" role="tabpanel" id="tab-2"><p>At a high level, the set A maintained by Kruskal’s algorithm is a set of disjoint trees. During update step i, if the ith smallest edge connects different trees, merge the two trees connected by this edge. The algorithm progresses until eventually only one tree remains at which point the set A represents an MST of the graph.<br><br>
Kruskal’s algorithm utilizes the union-find (aka disjoint set) data structure in order to handle the merging of the disjoint trees maintained by the algorithm. The union-find data structure supports disjoint sets with the following operations:<br><br>• makeset(u): creates a new set containing u provided that u is not in any other set<br> • find(u): returns the name of the set containing u
<br>• union(u,v): merge the set containing u and the set containing v into one set<br><br></p>
<pre>
Psuedo code:
A←∅
E′ ← sort edges by weight in non-decreasing order foreach v ∈ V do
makeset(v )
foreach(u,v)∈E′ do
    if find(u)!= find(v) then
        A ← A ∪ {(u, v )}
        union(u,v)
return A

Running time The runtime of Kruskal’s algorithm depends on two factors: the time to sort the edges by weight and the runtime of the union-find data structure operations. While Ω(m log n) time is required for sorting the edges if we use comparison-based sorting, in many cases, we may be able to sort the edges in linear time. (Recall, that RadixSort can be used to sort the edges in O(m) time if the weights are given by integers bounded by a polynomial in m.) In this case, the runtime is bounded by the runtime of the union-find operations and is given by O(nT (makeset) + mT (find) + nT (union)). The best known data structure supporting the union-find operations runs in amortized time O(α(n)) where α(n) is the inverse Ackermann function. Interestingly, the value of the inverse Ackermann is tiny for all practical purposes:
α(n) ≤ 4, ∀n < # atoms in the universe
and thus for all practical purposes, the union-find operations run in constant time. Thus, in
many settings, the runtime of Kruskal’s algorithm is nearly linear in the number of edges.
The actual definition of α(n) is α(n) = min{k | A(k) ≥ n}, where A(k) is the Ackermann function evaluated at k. A(k) itself is defined using the more general Ackermann function as A(k) = Ak(2). Ak(x) is defined recursively:
     For example
        x + 1  ,  m = 0
Am(x) = Am−1(1) ,  m > 0,x = 0
        Am−1(Am(x − 1)) , else
                                   

</pre></div>
                            <div class="tab-pane" role="tabpanel" id="tab-3">
                                <p>Content for tab 3.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <p>Prim's Example:-&gt;&nbsp;</p><img src="assets/img/Screen%20Shot%202021-12-01%20at%2010.23.39%20AM.png" width="800"/><img src="assets/img/Screen%20Shot%202021-12-01%20at%2010.23.48%20AM.png" width="800"/><img src="assets/img/Screen%20Shot%202021-12-01%20at%2010.23.54%20AM.png" width="800"/>
            </div>
        </div>
    </section>
    <div class="bg-dark text-secondary px-4 py-5 text-center">
        <div class="py-5">
            <h1 class="display-5 fw-bold text-white"><strong>MST</strong><br></h1>
            <div class="col-lg-6 mx-auto">
                <p class="fs-5 mb-4">DO you know that k clustering problem can be viewed as finding an MST and deleting the k-1 most<br>expensive edges.<br></p>
                <div class="d-grid gap-2 d-sm-flex justify-content-sm-center"><button class="btn btn-outline-info btn-lg px-4 me-sm-3 fw-bold" type="button">Last</button><button class="btn btn-outline-light btn-lg px-4" type="button">Next</button></div>
            </div>
        </div>
    </div>
    <script src="assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="assets/js/stylish-portfolio.js"></script>
</body>

</html>
