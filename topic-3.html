<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>AADproject</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic">
    <link rel="stylesheet" href="assets/css/Kalmansk-Regular.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu+Mono">
    <link rel="stylesheet" href="assets/fonts/fontawesome-all.min.css">
    <link rel="stylesheet" href="assets/fonts/font-awesome.min.css">
    <link rel="stylesheet" href="assets/fonts/ionicons.min.css">
    <link rel="stylesheet" href="assets/fonts/material-icons.min.css">
    <link rel="stylesheet" href="assets/fonts/simple-line-icons.min.css">
    <link rel="stylesheet" href="assets/fonts/typicons.min.css">
    <link rel="stylesheet" href="assets/fonts/fontawesome5-overrides.min.css">
    <link rel="stylesheet" href="assets/css/Boostrap-Tabs.css">
    <link rel="stylesheet" href="assets/css/CoolFont---Text-Container.css">
    <link rel="stylesheet" href="assets/css/gradient-navbar-1.css">
    <link rel="stylesheet" href="assets/css/gradient-navbar.css">
</head>

<body>
    <nav class="navbar navbar-dark navbar-expand-md" id="app-navbar">
        <div class="container-fluid"><a class="navbar-brand" href="#"><i class="fas fa-cogs"></i></a><button data-bs-toggle="collapse" class="navbar-toggler" data-bs-target="#navcol-1"><span class="visually-hidden">Toggle navigation</span><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navcol-1">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item"><a class="nav-link" href="#">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</a></li>
                    <li class="nav-item"><a class="nav-link active" href="#">Greedy</a></li>
                    <li class="nav-item"></li>
                    <li class="nav-item"></li>
                </ul>
            </div>
        </div>
    </nav>
    <div class="p-5 mb-4 bg-light round-3">
        <div class="container-fluid py-5">
            <h1 class="display-5 fw-bold">What are Greedy Algorithms??</h1>
            <p class="col-md-8 fs-4">A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage with the intent of finding a global optimum.&nbsp; &nbsp; (not so understandable answer ,is it??)<br><br>So, Suppose we want to solve a problem, and we’re able to come up with some recursive formulation of the problem that would give us a nice dynamic programming algorithm. But then,upon further inspection, we notice that any optimal solution only depends on looking up the optimal solution to one other subproblem. A greedy algorithm is an algorithm which exploits such a structure, ignoring other possible choices. Greedy algorithms can be seen as a refinement of dynamic programming; in order to prove that a greedy algorithm is correct, we must<br>prove that to compute an entry in our table, it is sufficient to consider at most one other<br>table entry; that is, at each point in the algorithm, we can make a “greedy”, locally-optimalchoice, and guarantee that a globally-optimal solution still exists. Instead of considering multiple choices to solve a subproblem, greedy algorithms only consider a single subproblem, so<br>they run extremely quickly – generally, linear or close-to-linear in the problem size.<br><br>Disadvantage :Unfortunately, greedy algorithms do not always give the optimal solution,<br>BUT , they frequently give good (approximate) solutions. To give a correct greedy algorithm one must first identify optimal substructure (as in dynamic programming), and then argue that at each step, you<br>only need to consider one subproblem. That is, even though there may be many possible subproblems to recurse on, given our selection of subproblem, there is always an optimal solution that contains the optimal solution to the selected subproblem.<br>Famous example -&gt; activity selection problem&nbsp;<br></p>
        </div>
        <div class="container-fluid py-5">
            <h1 class="display-5 fw-bold">One more Famous example -&gt; Kruskal's algorithm</h1>
            <p class="col-md-8 fs-4">What we do in Kruskal ? Firstly sort the edges according to their weight. Then we choose that edge which has minimal weight. We add that edge if it makes no cycle. Thus we go forward greedily. So it is greedy approach. :)&nbsp;The greedy approach is called&nbsp;<strong>greedy</strong>&nbsp;because, it takes optimal choice in each stage expecting, that will give a total optimal solution.<br>The "greedy algorithm" is about making choices in sequence such that each individual choice is best according to some limited "short-term" criterion that is not too expensive to evaluate.&nbsp;Here in Kruskal's algorithm, the "choice" is "picking the edge with the next lowest weight and do not form a cycle with already picked edges" and it is not too expensive to evaluate given the sorting algorithm and the union-find data structure.<br><br>Pseudo code :<br><br>KRUSKAL(G):<br>A = ∅<br>foreach v ∈ G.V:<br>&nbsp; &nbsp; &nbsp; MAKE-SET(v)<br>foreach (u, v) ordered by weight(u, v), increasing:<br>&nbsp; &nbsp; &nbsp; if FIND-SET(u) ≠ FIND-SET(v):<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A = A ∪ {(u, v)}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UNION(u, v)<br>&nbsp;return A<br><br></p><img src="assets/img/Screen%20Shot%202021-12-01%20at%201.54.32%20PM.png" width="800"/><img src="assets/img/Screen%20Shot%202021-12-01%20at%201.54.42%20PM.png" width="800"/><img src="assets/img/Screen%20Shot%202021-12-01%20at%201.54.47%20PM.png" width="800"/><img src="assets/img/Screen%20Shot%202021-12-01%20at%201.54.54%20PM.png" width="800"/>
        </div>
    </div>
    <section class="container-padding">
        <div class="container">
            <div class="p-5 mb-4 bg-light round-3">
                <div class="container-fluid py-5">
                    <h1 class="display-5 fw-bold">Huffman Coding&nbsp;</h1>
                    <p class="col-md-8 fs-4">Huffman found greedy algorithm to find the most efficient binary code, which we know today<br>as Huffman codes.<br><br> The basic idea is this: build subtrees for subsets of characters and merge them from the<br>bottom up, combining the two trees with the characters of minimum total frequency.<br><br>Example of Pseudo code:<br><br><strong>Input</strong>: Set of characters C = {c1,c2,...,cn} of size n, and<br>F = {f (c1),f (c2),...,f (cn)}, a set of frequencies.<br>Create nodes Nk for each character ck , with key f (ck ).<br>Let current denote the set {N1, . . . , Nn} of nodes.<br><br><strong>while</strong> current has length more than one <strong>do</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Find the two nodes Ni and Nj in current with the-&nbsp; minimum frequencies and create a new intermediate- node I with Ni and Nj as its children, so that <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;I.key = Ni .key + Nj .key.<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Add I to current and remove Ni , Nj .<br>return the only entry of current, which is the root of the tree.<br><br>The proof of correctness of Huffman codes are given by inductive hypothesis.</p>
                </div>
            </div>
        </div>
    </section>
    <div class="bg-dark text-secondary px-4 py-5 text-center">
        <div class="py-5">
            <h1 class="display-5 fw-bold text-white"><strong>Greedy</strong><br></h1>
            <div class="col-lg-6 mx-auto">
                <p class="fs-5 mb-4">The more greedy I become , The more less cost I want to waste at every point of my traversal in graph .</p>
                <div class="d-grid gap-2 d-sm-flex justify-content-sm-center"><button class="btn btn-outline-info btn-lg px-4 me-sm-3 fw-bold" type="button">Last</button><button class="btn btn-outline-light btn-lg px-4" type="button">First</button></div>
            </div>
        </div>
    </div>
    <script src="assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="assets/js/stylish-portfolio.js"></script>
</body>

</html>
